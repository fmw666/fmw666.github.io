{"meta":{"title":"范茂伟的个人博客","subtitle":"Stay hungry,Stay foolish","description":"一个大学学生，将自己平时学的一些东西放在上面，希望结交更多的朋友","author":"范茂伟","url":"http://fmw666.github.io"},"pages":[{"title":"[404]","date":"2019-11-26T06:20:19.061Z","updated":"2018-11-03T13:14:48.000Z","comments":true,"path":"404.html","permalink":"http://fmw666.github.io/404.html","excerpt":"","text":""},{"title":"嗨，欢迎您","date":"2019-11-26T06:20:19.082Z","updated":"2018-11-04T15:51:38.000Z","comments":true,"path":"about/index.html","permalink":"http://fmw666.github.io/about/index.html","excerpt":"","text":"茫茫人海能遇见你，是一种缘分。 如果你喜欢我的一些分享，请与我交个朋友吧！"}],"posts":[{"title":"计算机中有趣的递归缩写命名","slug":"计算机中有趣的递归缩写命名","date":"2020-02-16T11:19:40.000Z","updated":"2020-02-16T18:36:28.254Z","comments":true,"path":"2020-02-16/计算机中有趣的递归缩写命名/","link":"","permalink":"http://fmw666.github.io/2020-02-16/计算机中有趣的递归缩写命名/","excerpt":"","text":"🤔 什么是递归缩写命名？&emsp;&emsp;递归（recursion），是计算机科学中，一种程序调用自身的编程技巧。 &emsp;&emsp;举一个 C 语言递归函数调用的例子： 12345678910111213141516171819#include &lt;stdio.h&gt;//求n的阶乘long factorial(int n) &#123; if (n == 0 || n == 1) &#123; return 1; &#125; else &#123; return factorial(n - 1) * n; // 递归调用 &#125;&#125;int main() &#123; int a; printf(\"Input a number: \"); scanf(\"%d\", &amp;a); printf(\"Factorial(%d) = %ld\\n\", a, factorial(a)); return 0;&#125; &emsp;&emsp;递归缩写（Recursive acronym）命名呢？即递归首字缩写，是一种在全称中递归引用它自己的缩写。 🔍 递归缩写命名历史&emsp;&emsp;“在计算机领域，使用递归缩写是黑客社区中的一个较早的传统，后来又有一些牛人把自己开发的产品或者技术使用了这种方式来命名。” &emsp;&emsp;“最早的递归缩写命名的实例应该是 1977 年或 1978 年出现的 TINT 编辑器，其命名为 ‘TINT Is Not TECO’（TINT 不是文字编辑器和修正器），它是一个 MagicSix 的编辑器。这又启发了麻省理工大学的两个 Lisp Machine 编辑器的命名，一个叫做 EINE（‘EINE Is Not Emacs’，EINE 不是 Emacs），另一个是 ZWEI（‘ZWEI Was EINE Initially’，ZWEI 一开始是 EINE）。熟悉 Linux 的童鞋一定对 GNU 不陌生，Richard Stallman 的 GNU（GNU’s not UNIX，GNU 不是 UNIX）同样也是如此的幽默。如GNU一样，许多递归缩写包括否定语，通常用来指出这个缩写指代的事物 a 不是与另一个事物 b 相类似（但事实上，这个事物 a 通常与 b 非常相似甚至是 b 的衍生品）。” 👆 上两段均摘自网络 🎈 其他一些递归缩写命名 PNG：PNG’s Not GIF，一种图像文件存储格式，其设计目的是试图替代 GIF 和 TIFF 文件格式，同时增加一些 GIF 文件格式所不具备的特性。PNG 的名称来源于“可移植网络图形格式(Portable Network Graphic Format，PNG)” EMACS — EMACS Makes A Computer Slow，其自我调侃的意味就太明显了，大概也是对自己集成的强大的功能洋洋得意吧。 NoSQL — Not Only SQL，提倡运用非关系型数据库的数据存储。","categories":[{"name":"IT","slug":"IT","permalink":"http://fmw666.github.io/categories/IT/"}],"tags":[{"name":"命名","slug":"命名","permalink":"http://fmw666.github.io/tags/命名/"},{"name":"递归","slug":"递归","permalink":"http://fmw666.github.io/tags/递归/"}]},{"title":"微信抢红包算法实现（Python）","slug":"微信抢红包算法实现","date":"2020-01-24T16:00:00.000Z","updated":"2020-02-16T11:22:09.450Z","comments":true,"path":"2020-01-25/微信抢红包算法实现/","link":"","permalink":"http://fmw666.github.io/2020-01-25/微信抢红包算法实现/","excerpt":"","text":"💬 写在最前&emsp;&emsp;首先，新的一年，祝大家2020鼠年新春快乐啊！ &emsp;&emsp;同时，也希望武汉加油，中国加油，祝大家都能平平安安，健健康康。 图片均来自网络 (友情提醒，本文除此博客外，作者未在其他平台发布。如要引用，请先与本人取得联系，谢谢理解。) ❔ 问题提出&emsp;&emsp;新春虽然快乐，但我却有了迷惑。 &emsp;&emsp;什么迷惑呢？ &emsp;&emsp;相信大家这几天都会发红包，也会抢红包。可是，大家有想过，为什么自己就抢得这么少呢?(不会就我一人脸黑吧[手动狗头]) &emsp;&emsp;当然，这不是全部重点，重点还有，为什么抢到的有些红包这么吉利呢？(虽然少) &emsp;&emsp;比如，20元的红包，有人就会抢到 1.66元，0.88元，等诸如此类”幸运”的数字。 &emsp;&emsp;然后，我就开始好奇，微信抢红包的算法究竟是怎样实现的?（程序员上线） 🔍 开始思考&emsp;&emsp;首先，假如一次红包是100元(为了便于计算和理解)，然后红包个数是10个(只发一个就毫无必要计算了，抢就完事儿)，每次最小限额是0.01分(按照微信标准) &emsp;&emsp;有人会想，抢红包，不就 每个人获得剩余红包的一个随机数额 不就好了吗？(但注意要保证最后一个抢的人至少还有1分钱可以领) &emsp;&emsp;打比方，第一个抢红包的人领取的红包数额是0~100元之间的一个随机数额 &emsp;&emsp;第二个抢红包的人领取的红包数额是0~剩余数额(减去前面的人抢完之后) 之间的一个随机数额 &emsp;&emsp;依次往下，直到最后一个人抢完。 &emsp;&emsp;但这个时候”手残党”们可能会有意见了，其中会有聪明的人提出质疑：这个方法，只对那些 优先 抢红包的人有利，因为抢得越快，获得高金额红包的概率就越大！ &emsp;&emsp;真是这么回事吗？ &emsp;&emsp;其实不难发现，对于上述假设，10人平分100元红包，平均每个人能抢到10元钱。而如果采取刚刚那个算法，第一个抢的人则是从0~100的数额之间随机抢到一个大小，那么他能抢到的平均红包数额是50元！后面的人依次红包数额减小。所以，这个算法，仅对优先抢的人有利。正所谓，早起的鸟儿有虫吃，手速快的人，有钱领。 &emsp;&emsp;（稍微解释一下，我们这里所说的，只是优先抢的人，抢到高额红包的 概率 更大！并不是优先抢的人 一定 比后面抢的人红包更大） &emsp;&emsp;咳咳，可是，我们平时用微信抢红包真是这样的吗？ &emsp;&emsp;通过大家抢红包这么多年的经验看，好像微信抢红包对每一个人都是相对公平的吧？似乎没有区分过先来后到。 &emsp;&emsp;那么咱是不是就得考虑考虑其他算法了？不过，这个算法难道就不可行吗？我凭单身这么多年的手速，我多抢点钱不好吗？ &emsp;&emsp;所以，咱们就还是把这个算法用Python实现一下，至少它在某些方面是有可行之处的： 💡 编程解决 手速快，拿钱概率高 算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243# Python 内置随机数模块import random# 定义一个问题类class Q(object): # 初始化 def __init__(self, money=100.0, amount=10): # 红包大小 self.money = money # 红包数量 self.amount = 10 # 抢红包的人，人数等于红包数量 self.people = [0.0] * amount # 计算 def out(self): ''' 由于微信最小金额设置是0.01元， 为方便计算，我们红包数据先统一乘以 100 目的是将可能出现的小数转换为整数。 最后计算完成，再在原来数据上统一除以 100 ''' self.money *= 100 # 循环遍历每个人(开始抢)，但不包括最后一个人 for i in range(self.amount-1): # 为了保证后面每一个人至少还能领0.01元(*100=1) while True: # 模拟 do~while 语法 self.people[i] = random.randrange(1, self.money, 1) if self.money-self.people[i] &gt;= self.amount-1-i: self.money -= self.people[i] break # 还原数据 self.people[i] /= 100 # 剩余的钱都是最后一个人的 self.people[-1] = self.money / 100 # 输出 print(self.people)if __name__ == \"__main__\": q = Q(money=100.00, amount=10) q.out() 我们模拟20次输出（红包大小：100元，红包数量：10个），能发现，红包最后几个抢的人，是真的惨！（有兴趣的小伙伴，可以用这个代码多实现几次模拟数据，用于一些统计需求） 表格数据 1 2 3 4 5 6 7 8 9 10 1. 79.93 9.63 4.65 2.54 0.47 0.93 0.64 0.41 0.01 0.79 2. 9.45 89.06 1.13 0.04 0.2 0.04 0.02 0.04 0.01 0.01 3. 23.85 67.55 2.06 5.61 0.52 0.34 0.03 0.01 0.02 0.01 4. 80.07 0.57 16.13 1.72 1.43 0.02 0.02 0.01 0.02 0.01 5. 39.29 0.18 13.05 46.24 0.68 0.18 0.22 0.03 0.04 0.09 6. 71.5 17.01 8.53 0.75 1.77 0.36 0.05 0.01 0.01 0.01 7. 48.0 1.47 9.7 1.92 10.15 27.14 0.49 0.35 0.74 0.04 8. 56.67 0.54 5.08 24.82 4.3 6.51 0.83 1.06 0.05 0.14 9. 64.13 2.65 19.91 9.6 0.41 1.36 1.82 0.04 0.03 0.05 10. 81.75 6.85 8.45 0.29 0.46 1.06 0.99 0.02 0.12 0.01 11. 61.24 12.78 12.44 8.22 3.6 0.88 0.04 0.44 0.11 0.25 12. 42.43 5.23 14.21 26.55 6.64 3.87 0.93 0.1 0.02 0.02 13. 18.14 49.41 10.03 13.62 0.62 4.89 1.67 0.71 0.35 0.56 14. 61.72 0.23 24.47 4.32 7.97 0.46 0.32 0.44 0.04 0.03 15. 21.97 8.93 6.02 23.73 1.77 4.55 1.08 1.71 3.65 26.59 16. 84.32 5.34 5.62 0.55 2.2 0.73 0.34 0.79 0.05 0.06 17. 4.93 35.89 48.15 5.01 5.41 0.26 0.24 0.08 0.01 0.02 18. 95.78 1.98 1.89 0.06 0.12 0.06 0.06 0.01 0.01 0.03 19. 0.53 32.19 31.53 3.17 7.36 23.21 1.63 0.31 0.05 0.02 20. 54.4 21.27 17.67 6.58 0.03 0.01 0.01 0.01 0.01 0.01 平均 50.005 18.438 13.036 9.267 2.806 3.843 0.572 0.329 0.267 1.438 &emsp;&emsp;现在我要模拟微信抢红包实现方式，即，咱不靠手速，纯靠运气，可以不。（可以是可以，不过我想插一句，如果红包个数一共就那么多个，因为你手速慢，而别人抢完了，何不多练练自己手速？） 如何才能公平？&emsp;&emsp;我们思考这个问题，可以把100元拟作成一条直线，10个人可以拟作成直线上不重合的9个点。即，我们可以在直线上随机取9个不重合的点，把直线随机分成10段，抢红包的人可以依次“获得”直线的每一段，直线的长度就是我们抢到的红包大小！ &emsp;&emsp;特别说明：本“抢红包算法”只是作者提出的一种可行思路，并不代表微信实际开发团队使用如此。微信开发团队使用的是什么算法我也不知道=.= 编程实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Python 内置随机数模块import random# 定义一个问题类class Q(object): # 初始化 def __init__(self, money=100.0, amount=10): # 红包大小 self.money = money # 红包数量 self.amount = 10 # 结点数，等于红包数量-1 self.node = [0] * (amount - 1) # 抢红包的人，人数等于红包数量 self.people = [0.0] * amount # 计算 def out(self): ''' 由于微信最小金额设置是0.01元， 为方便计算，我们红包数据先统一乘以 100 目的是将可能出现的小数转换为整数。 最后计算完成，再在原来数据上统一除以 100 ''' self.money *= 100 for i in range(self.amount-1): while True: # 模拟 do~while 语法 n = random.randrange(1, self.money, 1) if n not in self.node: # 新生成的随机结点不在 node 列表中则满足 self.node[i] = n break # 对结点进行升序排序 self.node.sort() # 根据结点间长度生成每人红包大小 self.people[0] = self.node[0] / 100 self.people[-1] = (self.money - self.node[-1]) / 100 for i in range(1, self.amount-1): self.people[i] = (self.node[i] - self.node[i-1]) / 100 # 输出 print(self.people)if __name__ == \"__main__\": q = Q(money=100.00, amount=10) q.out() 模拟输出分析 1 2 3 4 5 6 7 8 9 10 1. 4.2 4.3 0.2 32.06 6.54 26.6 8.13 15.15 2.04 0.78 2. 20.63 17.94 2.87 7.44 3.97 4.04 2.61 9.4 5.15 25.95 3. 20.07 4.17 21.27 2.75 7.03 7.43 19.61 2.82 11.13 3.72 4. 8.55 12.49 11.0 8.9 20.6 3.65 0.27 16.04 9.22 9.28 5. 10.16 11.84 5.37 5.38 3.75 2.45 19.53 10.6 20.97 9.95 6. 25.76 14.73 4.44 3.78 4.61 8.38 0.69 2.71 21.19 13.71 7. 1.48 31.14 2.96 2.01 13.08 14.28 5.87 9.94 13.67 5.57 8. 7.21 22.63 0.64 6.81 20.79 9.2 6.43 4.44 17.44 4.41 9. 9.36 3.17 35.82 1.17 12.51 15.12 8.13 4.46 2.59 7.67 10. 5.1 5.28 1.92 8.2 8.96 10.21 32.12 1.58 26.36 0.27 11. 3.1 2.72 1.48 45.51 1.9 4.2 19.38 11.33 8.39 1.99 12. 4.09 2.22 9.43 2.11 31.25 2.06 6.41 5.79 32.19 4.45 13. 14.04 11.56 2.83 4.45 6.54 6.5 5.77 5.85 21.27 21.19 14. 2.57 0.61 32.13 8.6 12.36 8.33 7.89 11.98 10.88 4.65 15. 12.64 15.44 1.28 0.15 3.18 23.68 17.97 9.65 3.43 12.58 16. 5.5 11.73 16.35 0.47 10.99 13.77 6.28 26.55 4.47 3.89 17. 9.21 0.87 0.53 5.93 12.25 8.33 12.44 0.83 44.65 4.96 18. 5.81 4.78 19.94 8.17 2.26 0.64 15.44 0.36 7.98 34.62 19. 8.32 17.92 4.21 5.09 0.99 3.18 12.76 17.56 27.33 2.64 20. 28.29 2.91 2.25 23.93 10.0 22.27 0.16 3.63 0.36 6.2 平均 10.304 9.923 8.846 9.146 9.678 9.716 10.394 8.534 14.535 8.924 可以看到，只要样本数量足够大，每个人平均都能获得10元钱。即不分先后，抢到红包的人运气都“一样” 💸 程序优化&emsp;&emsp;通过上述算法，我们的确实现了 对于每个抢到红包的人，不分先后的获得了一个随机红包大小。但是，我们还没有实现红包数额的 “吉利化”。 &emsp;&emsp;（其实通过样本数据我们能看到，每一次红包分配出的金额里，都会有几个相对吉利的数字。吉不吉利主要也是看人们的心态，虽然我并不知道微信抢红包算法是如何实现，但是我觉得此算法已经可以使用） &emsp;&emsp;——“所以你就不想实现红包数额的‘吉利化’了吗？你就想偷懒了吗？” &emsp;&emsp;——“不不不，纵使我觉得上述算法已经可以，但是大过年的，我还是希望每个抢到红包的人都能获得一个相对吉利的红包数额！” 如何取得更多的吉利数字？&emsp;&emsp;像，6、8、9，包括1（幺，等同于“要”）这样的数字，是大家普遍比较喜爱的。我们要让这些数字尽可能多的出现在我们抢到的红包数额中。 &emsp;&emsp;这里有两种考虑模式：1.“被动”选择、2.“主动”选择 1. “被动”选择&emsp;&emsp;何为“被动”选择？即我们按照上述第二种算法，照常算出一组结果（用列表或数组存储）。再对每个人抢到的红包数额做分析，如果出现 吉利数 的频次符合我们的预期，则保留我们这组结果，否则，重新获取一组新的结果。循环直到满足退出。 &emsp;&emsp;注意： 这样的编程逻辑虽然很简单，但是要使用到我们的 do~while 直到型循环，而 Python 中并不提供这样的原生语法，所以我们只能通过语法逻辑，自己构建。 &emsp;&emsp;这样的算法模式，优点是，不需要我们去做大量的前期数据处理工作，用大量的随机结果去满足我们需要的条件。很明显，对比于后面我们要讲的“主动”选择，会提高大量的时间复杂度！ &emsp;&emsp;下面就结合上述第二例代码来实现一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Python 内置随机数模块import random# 定义一个幸运数类class Lucky(object): # 初始化 def __init__(self, lucky_numbers=[]): # 默认 1,6,8,9 是幸运数 self.lucky_numbers = [1, 6, 8, 9] # 用户可以提供其他幸运数 self.lucky_numbers += lucky_numbers # 消去重复元素，先取其集合，再取其列表 self.lucky_numbers = list(set(self.lucky_numbers)) # 是否是幸运数 def is_lucky(self, number): # 使用仿三元表达式 ?: return True if number in self.lucky_numbers else False# 定义一个问题类class Q(object): # 初始化 def __init__(self, money=100.0, amount=10): # 红包大小 self.money = money # 红包数量 self.amount = 10 # 结点数，等于红包数量-1 self.node = [0] * (amount - 1) # 抢红包的人，人数等于红包数量 self.people = [0.0] * amount # 计算 def out(self): ''' 由于微信最小金额设置是0.01元， 为方便计算，我们红包数据先统一乘以 100 目的是将可能出现的小数转换为整数。 最后计算完成，再在原来数据上统一除以 100 ''' self.money *= 100 for i in range(self.amount-1): while True: # 模拟 do~while 语法 n = random.randrange(1, self.money, 1) if n not in self.node: # 新生成的随机结点不在 node 列表中则满足 self.node[i] = n break # 对结点进行升序排序 self.node.sort() # 根据结点间长度生成每人红包大小 self.people[0] = self.node[0] / 100 self.people[-1] = (self.money - self.node[-1]) / 100 for i in range(1, self.amount-1): self.people[i] = (self.node[i] - self.node[i-1]) / 100 # 输出 return self.peopleif __name__ == \"__main__\": # 实例化 Lucky 类 l = Lucky() # 预期达到频次 freq = 0.5 # 红包结果 results = [] # 模拟 do~while 语法 while True: # 满足幸运数个数 count = 0 # 数字总数 total = 0 # 实例化 Q 类 q = Q(money=100.00, amount=10) results = q.out() # 取得每个人红包数额 for r in results: # 对红包数额字符串化(乘以100消去小数点) string = str(int(r*100)) # 取得字符串中每个字符 for char in string: # 字符转数字 num = int(char) if l.is_lucky(num): count += 1 total += 1 # 满足频次则退出 if count / total &gt; freq: break # 输出 print(results) 2. “主动”选择&emsp;&emsp;何为“主动”选择？相比于“被动”选择，我们只做完备的前期数据处理，一次结果输出，即满足我们的结果。而不需要“被动”选择中用 直到型循环 去试结果。 &emsp;&emsp;可是，前期数据处理？这就难办了… &emsp;&emsp;首先，如果发的红包数额相对较大，别人抢到大红包（大于10元）的概率也就越大。我们这里先做一个 “约定”：抢到10元以上红包的人，就不考虑将其数字吉利化了，因为抢到10元红包以上的人，我相信不会特别在乎是不是10.66元或者18.88元，从金额上说，他们大概率也都满足了，所以我们只对那些只抢到10元以下红包的人做数字吉利化。（这也是为了方便行事，说白也算是一种偷懒=。=） &emsp;&emsp;所以，这个问题就被我们 简(tou) 化(lan) 成：对抢到的10元以下红包，多加入1、6、8、9这样的数字（如 0.66、0.68、0.88、1.68、1.99……） &emsp;&emsp;现在，我就先把这个思路留在这儿，供读者们自己去解决了！ &emsp;&emsp;感谢阅读！","categories":[{"name":"IT","slug":"IT","permalink":"http://fmw666.github.io/categories/IT/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://fmw666.github.io/tags/算法/"},{"name":"抢红包","slug":"抢红包","permalink":"http://fmw666.github.io/tags/抢红包/"}]},{"title":"《C语言》游戏开发基础","slug":"C语言游戏开发基础","date":"2018-11-28T06:02:20.000Z","updated":"2020-02-16T11:22:13.544Z","comments":true,"path":"2018-11-28/C语言游戏开发基础/","link":"","permalink":"http://fmw666.github.io/2018-11-28/C语言游戏开发基础/","excerpt":"","text":"🚀 《C语言》游戏开发基础 游戏框架搭建12345678910111213// 函数外全局变量定义int main()&#123; startup(); // 数据初始化 while (1) // 游戏循环执行 &#123; show(); // 显示画面 updateWithoutInput(); // 与用户输入无关的更新 updateWithInput(); // 与用户输入有关的更新 &#125; return 0;&#125; 目录功能性 清屏函数 延时函数 停止等待函数 系统自带发出铃声 读取键盘上输入的值(需要回车) 读取键盘上输入的值(不需要回车) 判断是否有键盘输入的函数 产生随机数的函数 光标移动到原点位置进行重画(实现类似于清屏函数的效果) 隐藏光标显示函数 添加背景音乐 计时函数 窗口 修改窗口大小(静态) 修改窗口大小(动态) 固定窗口大小 修改窗体风格 设置指定窗口的显示状态 修改窗口标题 弹出消息框 修改字体颜色、背景颜色 修改文本颜色 修改窗体icon图标 修改窗体透明度 清屏函数 12#include &lt;stdlib.h&gt;system(\"cls\"); 延时函数 12#include &lt;windows.h&gt;Sleep(20); //其中20的单位为毫秒 停止等待函数 12#include &lt;windows.h&gt;system(\"pause\"); 系统自带发出铃声 1printf(\"\\a\"); 读取键盘上输入的值(需要回车) 1234char input;scanf(\"%c\",&amp;input);if(input=='w') printf(\"w\"); 读取键盘上输入的值(不需要回车) 1234567#include&lt;conio.h&gt;char input;//scanf(\"%c\",&amp;input);input = getch();if(input=='w') printf(\"w\"); 判断是否有键盘输入的函数 12#include &lt;conio.h&gt;kbhit(); //若有则返回一个非0值，否则返回0 示例： 123456789101112#include &lt;stdio.h&gt;#include &lt;conio.h&gt;int main()&#123; char input; if(kbhit())&#123; scanf(\"%c\",&amp;input); //需要按下回车键来读取 //input=getch(); printf(\"按下了键\\n\"); &#125;&#125; 123456789101112#include &lt;stdio.h&gt;#include &lt;conio.h&gt;int main()&#123; char input; if(kbhit())&#123; //scanf(\"%c\",&amp;input); input=getch(); //不需要按下回车键来读取 printf(\"按下了键\\n\"); &#125;&#125; 产生随机数的函数 12#include&lt;stdlib.h&gt;rand(); 光标移动到原点位置进行重画(实现类似于清屏函数的效果) 123456789101112131415#include &lt;windows.h&gt;void gotoxy(int x,int y)//类似于清屏函数，光标移动到原点位置进行重画&#123; HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(handle,pos);&#125;int main()&#123; gotoxy(0,0);&#125; 隐藏光标显示函数 123456789101112#include &lt;windows.h&gt;void HideCursor()&#123; CONSOLE_CURSOR_INFO cursor_info=&#123;1,0&#125;; //第二个值为0表示隐藏光标 SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE),&amp;cursor_info);&#125;int main()&#123; HideCursor();&#125; 返回目录 修改窗口大小(静态) 12#include &lt;windows.h&gt;system(\"mode con cols=30 lines=20\"); //其中30为宽的值，20为高的值 修改窗口大小(动态) 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;windows.h&gt;void setWinSize(int height,int width)&#123; char str[20]; sprintf(str, \"mode con: cols=%d lines=%d\", height, width); system(str);&#125;int main()&#123; int height, width; scanf(\"%d %d\", &amp;height, &amp;width); //输入高和宽的值 setWinSize(height,width);&#125; 固定窗口大小 123456789101112#include &lt;windows.h&gt;void fixWinSize() &#123; HWND hWnd = GetConsoleWindow(); //获得cmd窗口句柄 RECT rc; GetWindowRect(hWnd, &amp;rc); //获得cmd窗口对应矩形 //改变cmd窗口风格 SetWindowLongPtr(hWnd,GWL_STYLE, GetWindowLong(hWnd, GWL_STYLE) &amp; ~WS_THICKFRAME &amp; ~WS_MAXIMIZEBOX &amp; ~WS_MINIMIZEBOX);&#125;fixWinSize(); 修改窗体风格 12345678910#include &lt;windows.h&gt;void setWinLong()&#123; HWND hwnd = GetConsoleWindow(); LONG Style; //窗口风格 Style = GetWindowLong(hwnd, GWL_STYLE); // 得到窗口风格 Style = Style &amp; ~WS_CAPTION; //去掉标题栏，网上可查选 SetWindowLong(hwnd, GWL_STYLE, Style); //为窗口设置新的风格&#125; 设置指定窗口的显示状态 1234#include &lt;windows.h&gt;ShowWindow(FindWindowA(\"ConsoleWindowClass\",NULL),SW_HIDE); //隐藏窗口ShowWindow(FindWindowA(\"ConsoleWindowClass\",NULL),SW_SHOW); //显示窗口 修改窗口标题 方法一： 12#include &lt;windows.h&gt;SetConsoleTitleA(\"name\"); 方法二： 12#include &lt;windows.h&gt;system(\"title name\"); 弹出消息框 123#include &lt;windows.h&gt;MessageBoxA(0,\"内容\",\"标题\",MB_OK|MB_SYSTEMMODAL); //MB_OK表示有确认键，MB_SYSTEMMODAL表示在窗口置顶 修改字体颜色、背景颜色 方法一： 12345678910111213141516#include &lt;windows.h&gt;system(\"color 07\"); //(07)为默认的黑底白字。其中0为背景色，7为前景色/*颜色属性由两个十六进制数字指定 -- 第一个为背景色，第二个则为前景色。每个数字可以为以下任何值之一:0 = 黑色 8 = 灰色1 = 蓝色 9 = 淡蓝色2 = 绿色 A = 淡绿色3 = 湖蓝色 B = 淡浅绿色4 = 红色 C = 淡红色5 = 紫色 D = 淡紫色6 = 黄色 E = 淡黄色7 = 白色 F = 亮白色*/ 方法二： 123456789#include &lt;windows.h&gt;void SetColor(unsigned short BackGroundColor,unsigned short ForeColor)&#123; HANDLE hCon=GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hCon,(ForeColor%16)|(BackGroundColor%16*16));&#125;SetColor(0,7); //(0,7)为默认的黑底白字。其中0为背景色，7为前景色 示例： 123456789101112131415161718192021#include &lt;windows.h&gt;#include &lt;stdio.h&gt;void SetColor(unsigned short BackGroundColor,unsigned short ForeColor)&#123; HANDLE hCon=GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hCon,(ForeColor%16)|(BackGroundColor%16*16));&#125;int main()&#123; system(\"color 70\"); printf(\"方法一\\n\"); int i,j; while(scanf(\"%d %d\",&amp;i,&amp;j)) &#123; SetColor(i,j); printf(\"方法二\\n\"); &#125;&#125; 修改文本颜色 12#include &lt;windows.h&gt;SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 2); //设置颜色 添加背景音乐 1// 只在VC上支持 计数函数 方法一： 1234567891011121314#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;windows.h&gt;int main()&#123; clock_t start,end; start = clock(); Sleep(2000); end = clock(); printf(\"time=%f\\n\",(double)(end-start)/CLK_TCK);&#125; 方法二： 12345678910111213#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main()&#123; DWORD end,start; start= GetTickCount(); Sleep(2000); end= GetTickCount(); printf(\"time=%d\\n\",end-start);&#125; 修改字体大小 1//暂未 修改窗体icon图标 1Dev-C++ 新建项目-&gt;`Ctrl+H`(项目属性) 修改窗体透明度 123456789101112131415#include &lt;windows.h&gt;void setWinTransparent()&#123; HWND hwnd = GetConsoleWindow(); int ExdStyle = (int)GetWindowLong(hwnd, GWL_EXSTYLE); //通过SetWindowLong设置窗口的属性，多增加了一个WS_EX_LAYERED支持透明 SetWindowLong(hwnd, GWL_EXSTYLE, ExdStyle | WS_EX_LAYERED); SetLayeredWindowAttributes(GetConsoleWindow(),RGB(255, 255, 255), 200, LWA_ALPHA);//200为透明度值（0-255）&#125;int main()&#123; setWinTransparent();&#125; 键盘输入上下左右，回车确定，Esc退出 12345678910111213141516171819char input;while(1)&#123; input=getch(); if(input==27)&#123; //Esc键ASCII码为27 &#125; if(input==13)&#123; //回车键ASCII码为13 &#125; if(input!=-32) continue; //避免因从键盘上输入的其他无关值影响程序进行 input=getch(); //在读取上下左右ASCII码前必须添加 if(input==72)&#123; //上的ASCII码为72 &#125; if(input==80)&#123; //下的ASCII码为80 &#125; if(input==75)&#123; //左的ASCII码为75 &#125; if(input==77)&#123; //右的ASCII码为77 &#125;&#125; 返回目录","categories":[{"name":"IT","slug":"IT","permalink":"http://fmw666.github.io/categories/IT/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://fmw666.github.io/tags/C语言/"},{"name":"游戏","slug":"游戏","permalink":"http://fmw666.github.io/tags/游戏/"}]},{"title":"git教程","slug":"git教程","date":"2018-11-02T11:18:43.000Z","updated":"2020-02-16T11:22:17.268Z","comments":true,"path":"2018-11-02/git教程/","link":"","permalink":"http://fmw666.github.io/2018-11-02/git教程/","excerpt":"","text":"⚡Git是目前世界上最先进的分布式版本控制系统（没有之一）。 在Windows上安装Git Git官网直接下载安装程序，（网速慢的同学请移步国内镜像） 安装完成后，在开始菜单里找到&quot;Git&quot;-&gt;&quot;Git Bash&quot;,进行如下配置： 12$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 生成相应的令牌，本地一份，Github 一份，这样 Github 可以在你使用仓库的时候，进行校验确定你的身份。 123$ cd ~/.ssh$ mkdir key_backup$ ssh-keygen -t rsa -C &quot;email@example.com&quot; 生成如下两个文件： id_rsa.pub 就是我们待会需要的公钥文件，使用命令 $ cat id_rsa.pub 再将内容复制到剪切板，然后进入github账号设置里面添加SSH key 然后输入 $ ssh -T git@github.com 测试连通状态 创建本地仓库 选择一个本地文件夹，用作保存本地仓库文件，尽量是空文件夹。 然后使用命令 $ git init 初始化文件夹。 其实是在当前文件夹下生成一个叫 .git 的隐藏文件夹，里面是一些配置文件，不要随意更改。 使用 $ git clone https://github.com/name/repository.git 将远程仓库克隆到本地此文件夹下。 name 是自己的昵称，repository 是自己的仓库名，不要忘记末尾的 .git 后缀。 然后此文件夹下会多一个和你仓储名一样的文件夹，内部文件与远程仓库一样。 常用命令 1234567$ git add . //添加文件$ git commit -m &quot;commit-messages&quot; //提交本地仓库$ git push origin master //提交远程仓库$ git pull //拉取远程文件，与以下命令类似$ git branch temp //创建本地分支$ git fetch origin master:temp$ git merge master 图床介绍 写博客就无法避免上传图片，图床就是这么一个地方，就是一个网站，你发自己的图片上传到它的网站，然后它给你一个这个图片的链接，插入博客中就能显示图片了。 推荐一个知名的，七牛云https://portal.qiniu.com/，注册完实名认证后有一些优惠。 还有一个神奇的网站：https://sm.ms/，也能用 Hexo+github博客搭建 推荐一个CSDN博主的文章，点击这里 一个git用户很详细的分享，点击这里 当然，官方教程更全面，点击这里 这里分享一篇我的总结，点击这里","categories":[{"name":"IT","slug":"IT","permalink":"http://fmw666.github.io/categories/IT/"}],"tags":[{"name":"git","slug":"git","permalink":"http://fmw666.github.io/tags/git/"},{"name":"后台","slug":"后台","permalink":"http://fmw666.github.io/tags/后台/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-31T16:00:00.000Z","updated":"2018-11-02T21:03:06.000Z","comments":true,"path":"2018-11-01/hello-world/","link":"","permalink":"http://fmw666.github.io/2018-11-01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}